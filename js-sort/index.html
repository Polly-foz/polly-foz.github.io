<!DOCTYPE html>
<html lang="zh-cn">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="Polly-foz">
  <meta name="description" content="Polly-foz的个人网站">
  <meta name="keywords" content="Polly-foz,front-end">
  
  <link rel="prev" href="http://yangpeiya.xyz/js-function-exec-time/" />
  <link rel="next" href="http://yangpeiya.xyz/jquery/" />
  <link rel="canonical" href="http://yangpeiya.xyz/js-sort/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           常见排序算法的JavaScript实现 | Polly-foz&#39;s Blog
       
  </title>
  <meta name="title" content="常见排序算法的JavaScript实现 | Polly-foz&#39;s Blog">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "http:\/\/yangpeiya.xyz\/"
    },
    "articleSection" : "posts",
    "name" : "常见排序算法的JavaScript实现",
    "headline" : "常见排序算法的JavaScript实现",
    "description" : "1. 选择排序 \/* * 选择排序 * 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置， * 然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 * 以此类推，直到所有元素均排序完毕。 *\/ \/\/ min ： 查找并返回数组中最小元素的值和下标 \/\/ T(n) = O(n), S(n) = O(1) let reducer = (currentMin,currentValue,currentIndex) =\x26gt; currentMin[0] \x26lt; currentValue ? currentMin : [currentValue,currentIndex] let min = (arr) =\x26gt; arr.reduce(reducer,[Infinity,-1]) \/\/ 循环实现 \/\/ T(n) = O(n**2) S(n) = O(1) let selection_sort_loop = (arr)=\x26gt;{ for(let i = 0; i \x26lt; arr.length; i\x2b\x2b){ let minValue = Infinity let minIndex = -1 for(let j = i; j \x26lt; arr.",
    "inLanguage" : "zh-cn",
    "author" : "Polly-foz",
    "creator" : "Polly-foz",
    "publisher": "Polly-foz",
    "accountablePerson" : "Polly-foz",
    "copyrightHolder" : "Polly-foz",
    "copyrightYear" : "2020",
    "datePublished": "2020-01-05 19:11:36 \x2b0800 HKT",
    "dateModified" : "2020-01-05 19:11:36 \x2b0800 HKT",
    "url" : "http:\/\/yangpeiya.xyz\/js-sort\/",
    "wordCount" : "592",
    "keywords" : [ "算法", "Polly-foz\x27s Blog"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="http://yangpeiya.xyz/">Polly-foz&#39;s Blog</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">文章</a>
                
                <a class="menu-item" href="/categories/" title="">分类</a>
                
                <a class="menu-item" href="/tags/" title="">标签</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="http://yangpeiya.xyz/">Polly-foz&#39;s Blog</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">文章</a>
                
                <a class="menu-item" href="/categories/" title="">分类</a>
                
                <a class="menu-item" href="/tags/" title="">标签</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">常见排序算法的JavaScript实现</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="http://yangpeiya.xyz/" rel="author">Polly-foz</a> with ♥ 
                <span class="post-time">
                on <time datetime=2020-01-05 itemprop="datePublished">January 5, 2020</time>
                updateAt <time datetime=Jan&#32;5,&#32;2020 itemprop="datePublished">Jan 5, 2020</time>
                </span>
                in
                <i class="iconfont icon-folder"></i>
                <span class="post-category">
                        <a href="http://yangpeiya.xyz/categories/javascript/"> JavaScript </a>
                        
                </span>
        </div>
    </header>
    <div class="post-content">
        

        

        
        
     
          
          
          

          
          
          

          

<h1 id="1-选择排序">1. 选择排序</h1>

<pre><code class="language-javascript">/*
 * 选择排序
 * 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，
 * 然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
 * 以此类推，直到所有元素均排序完毕。
 */

// min ： 查找并返回数组中最小元素的值和下标
//        T(n) = O(n), S(n) = O(1)
let reducer = (currentMin,currentValue,currentIndex) =&gt; currentMin[0] &lt; currentValue ? currentMin : [currentValue,currentIndex]
let min = (arr) =&gt; arr.reduce(reducer,[Infinity,-1])

// 循环实现
// T(n) = O(n**2) S(n) = O(1)
let selection_sort_loop = (arr)=&gt;{
  for(let i = 0; i &lt; arr.length; i++){
    let minValue = Infinity
    let minIndex = -1
    for(let j = i; j &lt; arr.length; j++){
      [minValue,minIndex] = minValue &lt; arr[j] ? [minValue,minIndex] : [arr[j],j]
    }
    arr[i] ^= arr[minIndex]
    arr[minIndex] ^= arr[i]
    arr[i] ^= arr[minIndex]
  }
  return arr //也可以不return
}

// 递归实现
// T(n) = O(n**2), S(n) = O(n**2)(concat产生) + O(n)(递归栈产生，递归深度)
let selection_sort_recursion = (arr)=&gt;{
  if(arr.length === 0)
    return []  
  //T(n) = O(n), S(n) = O(1)
  let [minValue,minIndex] = min(arr)
  arr.splice(minIndex,1)
  //concat每次返回一个新数组 S(n) = O(n)
  return [minValue].concat(selection_sort_recursion(arr))
}

// 测试代码
let arrs = [[],[2],[3,1,5],[9,2,5,43,-1,2,-9,-3,-9,10]]
// arrs.forEach((arr) =&gt; console.log(selection_sort_loop(arr)))
arrs.forEach((arr) =&gt; console.log(selection_sort_recursion(arr)))

</code></pre>

<h1 id="2-快速排序">2. 快速排序</h1>

<pre><code class="language-javascript">
/* 快速排序
 * （1）在数据集之中，选择一个元素作为&quot;基准&quot;（pivot）。
 * （2）所有小于&quot;基准&quot;的元素，都移到&quot;基准&quot;的左边；所有大于&quot;基准&quot;的元素，都移到&quot;基准&quot;的右边。
 * （3）对&quot;基准&quot;左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。
 * 以上文字摘自 http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html
 * 一种不稳定的排序算法
 */

/* 最优情况下：每次选择的pivot是中值
 * T(n) = 2T(n/2) + n, T(1) = 0
 * =&gt; T(n) = O(nlogn)
 * S(n) = S(logn) 递归栈产生(递归深度)
 *
 * 最差情况下：每次选择的pivot是最小值/最大值
 * T(n) = T(n-1) + T(1) + n, T(1) = 0
 * =&gt; T(n) = O(n**2)
 * S(n) = O(n) 递归栈产生(递归深度)
 *
 * 平均情况下：每次选择的pivot是第k小/大值
 * T(n) = 1/n * (Σ(k=1-&gt;n)(T(k-1) + T(n-k))) + n
 *      = 2/n * (Σ(k=1-&gt;n)T(k-1)) + n
 * =&gt; T(n) = O(nlogn)
 * S(n) = O(logn) 递归栈产生(递归深度)
 */
let quick_sort = (arr,start=0,end=arr.length-1) =&gt; {
    if(start &gt;= end)
        return arr
    let pivot = arr[start]
    let i = start
    let j = end
    while(i &lt; j){
        while(i &lt; j &amp;&amp; arr[j] &gt; pivot){
            j--
        }
        [arr[i],arr[j]] = [arr[j],arr[i]]
        i++
        while(i &lt; j &amp;&amp; arr[i] &lt; pivot){
            i++
        }
        [arr[i],arr[j]] = [arr[j],arr[i]]
        j--
    }
    quick_sort(arr,start,i-1)
    quick_sort(arr,i+1,end)
    return arr // 可以不return
 }

//测试代码
let arrs = [[],[2],[3,1,5],[9,2,5,43,-1,2,-9,-3,-9,10]]
arrs.forEach((arr) =&gt; console.log(quick_sort(arr)))

</code></pre>

<h1 id="3-归并排序">3. 归并排序</h1>

<pre><code class="language-javascript">/*
 * 归并操作的工作原理如下：
 * 第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
 * 第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置
 * 第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
 * 重复步骤3直到某一指针超出序列尾
 * 将另一序列剩下的所有元素直接复制到合并序列尾
 * 以上文字摘自https://baike.baidu.com/item/归并排序
 */


/* 递归实现
 * T(n) = 2T(n/2) + n, T(1) = 0
 * =&gt; T(n) = O(nlogn)
 * S(n) = O(logn) 递归栈深度 + O(n) temp占用空间 = O(n) ?
 * 超出3个数的数组就会栈溢出。。。?
 */

let merge_sort = (arr,start=0,end=arr.length-1) =&gt; {
    // console.log(`merge_sort,${start},${end}`)
    if(start == end){
        return
    }
    let middle = Math.floor(end/2)
    merge_sort(arr,start,middle)
    merge_sort(arr,middle+1,end)
    merge(arr,start,middle+1,end)
}

let merge = (arr,lstart,rstart,rend) =&gt; {
    // console.log(`merge,${lstart},${rstart},${rend}`)
    let temp = []
    let l = lstart
    let r = rstart
    let lend = rstart - 1

    while(l &lt;= lend &amp;&amp; r &lt;= rend){
        if(arr[l] &lt;= arr[r]){
            temp.push(arr[l])
            l += 1
        }else{
            temp.push(arr[r])
            r += 1
        }
    }
    while(l &lt;= lend){
        temp.push(arr[l])
        l += 1
    }
    while(r &lt;= rend){
        temp.push(arr[r])
        r += 1
    }

    for(let i = lstart; i &lt;= rend; i++){
        arr[i] = temp[i]
    }

}

//测试代码
let arrs = [[3,5,-2]]
arrs.forEach((arr) =&gt; (merge_sort(arr),console.log(arr)))

/* 循环实现
 * 
 */


</code></pre>

<h1 id="4-计数排序">4. 计数排序</h1>

<pre><code class="language-javascript">/*
 计数排序
（1）找出待排序的数组中最大和最小的元素
（2）统计数组中每个值为i的元素出现的次数，存入数组C的第i项
（3）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
（4）反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1
 以上文字摘自https://www.runoob.com/w3cnote/counting-sort.html

 =&gt; 待排序数组中元素值不能为负
*/

/*
T(n) = O(n + maxValue - minValue + 1)
S(n) = O(maxValue + 1)
*/

let min = (arr) =&gt; arr.reduce((currentMin,currentValue)=&gt;currentMin&lt;currentValue?currentMin:currentValue)
let max = (arr) =&gt; arr.reduce((currentMax,currentValue)=&gt;currentMax&gt;currentValue?currentMax:currentValue)
let counting_sort = (arr) =&gt; {
    if(arr.length === 0)
        return arr
    let minValue = min(arr)
    let maxValue = max(arr)
    // console.log(`min:${minValue}, max:${maxValue}`)
    let C = new Array(max+1)
    arr.forEach(element =&gt; {
        // console.log(element,C[element])
        C[element] = C[element] ? C[element] + 1 : 1
    });
    // console.log(C)
    let index = 0;
    for(let i = minValue; i &lt;= maxValue; i++){
        while(C[i] &gt; 0){
            arr[index] = i
            index += 1
            C[i] -= 1
        }
    }
    return arr //可以不写
}

//测试代码
let arrs = [[],[2],[3,1,5],[9,2,5,43,2,9,3,9,10]]
arrs.forEach((arr) =&gt; console.log(counting_sort(arr)))

</code></pre>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>Polly-foz </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=http://yangpeiya.xyz/js-sort/>http://yangpeiya.xyz/js-sort/</span>
            </p>
            
            
    </div>

  
    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-tag"></i>Tag(s): 
            
            <span class="tag"><a href="http://yangpeiya.xyz/tags/%E7%AE%97%E6%B3%95/">
                    #算法</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="http://yangpeiya.xyz/">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="http://yangpeiya.xyz/js-function-exec-time/" class="prev" rel="prev" title="JS 函数的执行时机"><i class="iconfont icon-left"></i>&nbsp;JS 函数的执行时机</a>
         
        
        <a href="http://yangpeiya.xyz/jquery/" class="next" rel="next" title="JQuery设计思想">JQuery设计思想&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

    <div class="post-comment">
          
                 
          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2019 - 2020</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="http://yangpeiya.xyz/">Polly-foz</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>












    
    
    <script src="/js/vendor_no_gallery.min.js" async=""></script>
    
  



     </div>
  </body>
</html>
